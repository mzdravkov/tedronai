// Generated by: main
// TypeWriter: ChunkedVec
// Directive: +gen on ComponentMask

package components

import (
	"bytes"
	"container/list"
	"fmt"
)

// This is an implementation of https://github.com/mzdravkov/chunked-vector
// The MIT License (MIT)
// Copyright (c) 2016 Mihail Zdravkov (mihail0zdravkov@gmail.com)

type ComponentMaskChunkedVec struct {
	List      *list.List
	ChunkSize uint
	Empty     ComponentMask
}

// Creates a new ComponentMaskChunkedVec with chunkSize as provided
func NewComponentMaskChunkedVec(chunkSize uint) *ComponentMaskChunkedVec {
	if chunkSize == 0 {
		chunkSize = 1024
	}

	return &ComponentMaskChunkedVec{
		List:      list.New(),
		ChunkSize: chunkSize,
	}
}

// Adds the element to the ChunkedVec and returns the position it was added to
func (cv *ComponentMaskChunkedVec) Add(element ComponentMask) (uint, uint) {
	listIndex := 0
	for e := cv.List.Front(); e != nil; e = e.Next() {
		for index, value := range e.Value.([]ComponentMask) {
			if value == cv.Empty {
				e.Value.([]ComponentMask)[index] = element
				return uint(listIndex), uint(index)
			}
		}

		listIndex++
	}

	slice := make([]ComponentMask, cv.ChunkSize)
	slice[0] = element
	cv.List.PushBack(slice)

	return uint(listIndex), uint(0)
}

// Overwrites the given position to hold the given value
func (cv *ComponentMaskChunkedVec) PutAt(element ComponentMask, listIndex, sliceIndex uint) {
	var i uint = 0
	e := cv.List.Front()
	for ; i < listIndex; e = e.Next() {
		i++
	}

	e.Value.([]ComponentMask)[sliceIndex] = element
}

// Puts the cv.Empty value at the given position
func (cv *ComponentMaskChunkedVec) DeleteAt(listIndex, sliceIndex uint) {
	cv.PutAt(cv.Empty, listIndex, sliceIndex)
}

// Returns the value that is on the given position
func (cv *ComponentMaskChunkedVec) Get(listIndex, sliceIndex uint) ComponentMask {
	e := cv.List.Front()
	for i := uint(0); i < listIndex; e = e.Next() {
		i++
	}

	return e.Value.([]ComponentMask)[sliceIndex]
}

// Adds chunks (list nodes) to the ComponentMaskChunkedVec
func (cv *ComponentMaskChunkedVec) Grow(n int) {
	if n < 0 {
		panic("Can't grow ComponentMaskChunkedVec with a negative amount")
	}

	for i := 0; i < n; i++ {
		slice := make([]ComponentMask, cv.ChunkSize)
		cv.List.PushBack(slice)
	}
}

// Remove list nodes that has arrays that are with the Empty element only
func (cv *ComponentMaskChunkedVec) Shrink() {
	for e := cv.List.Front(); e != nil; e = e.Next() {
		allEmpty := true
		for _, value := range e.Value.([]ComponentMask) {
			if value != cv.Empty {
				allEmpty = false
				break
			}
		}

		if allEmpty {
			cv.List.Remove(e)
		}
	}
}

// Returns the number of non-empty valued elements
func (cv *ComponentMaskChunkedVec) Len() int {
	number := 0

	for e := cv.List.Front(); e != nil; e = e.Next() {
		for _, value := range e.Value.([]ComponentMask) {
			if value != cv.Empty {
				number++
			}
		}
	}

	return number
}

// Returns the current capacity of the ComponentMaskChunkedVec
// i.e. the number of elements it can currently hold without growing
func (cv *ComponentMaskChunkedVec) Cap() int {
	return cv.List.Len() * int(cv.ChunkSize)
}

// Iter returns a channel of type ComponentMask that you can range over.
func (cv *ComponentMaskChunkedVec) Iter() <-chan ComponentMask {
	ch := make(chan ComponentMask)

	go func() {
		for e := cv.List.Front(); e != nil; e = e.Next() {
			for _, value := range e.Value.([]ComponentMask) {
				ch <- value
			}
			close(ch)
		}
	}()

	return ch
}

// Checks if the ComponentMaskChunkedVec contains the given element
func (cv *ComponentMaskChunkedVec) Contains(element ComponentMask) bool {
	for e := cv.List.Front(); e != nil; e = e.Next() {
		for _, value := range e.Value.([]ComponentMask) {
			if value == element {
				return true
			}
		}
	}

	return false
}

// Checks if the ComponentMaskChunkedVec contains all of the given element
func (cv *ComponentMaskChunkedVec) ContainsAll(searchingFor ...ComponentMask) bool {
	for _, s := range searchingFor {
		if !cv.Contains(s) {
			return false
		}
	}

	return true
}

// Checks if this ComponentMaskChunkedVec is equal to another one
// Two ComponentMaskChunkedVecs are equal if they have the same number of lists
// with slices that have the same values
func (cv *ComponentMaskChunkedVec) Equal(other *ComponentMaskChunkedVec) bool {
	// no worries, the complexity of this is O(1)
	if cv.List.Len() != other.List.Len() {
		return false
	}

	e2 := other.List.Front()
	for e1 := cv.List.Front(); e1 != nil; e1 = e1.Next() {
		len1 := len(e1.Value.([]ComponentMask))
		len2 := len(e2.Value.([]ComponentMask))
		if len1 != len2 {
			return false
		}

		for i := 0; i < len1; i++ {
			if e1.Value.([]ComponentMask)[i] != e2.Value.([]ComponentMask)[i] {
				return false
			}
		}

		e2 = e2.Next()
	}

	return true
}

// Clone returns a clone of the ComponentMaskChunkedVec.
// Does NOT clone the underlying elements.
func (cv *ComponentMaskChunkedVec) Clone() *ComponentMaskChunkedVec {
	clonedComponentMaskChunkedVec := NewComponentMaskChunkedVec(cv.ChunkSize)

	var listIndex uint = 0
	for e := cv.List.Front(); e != nil; e = e.Next() {
		for index, value := range e.Value.([]ComponentMask) {
			clonedComponentMaskChunkedVec.PutAt(value, listIndex, uint(index))
		}

		listIndex++
	}

	return clonedComponentMaskChunkedVec
}

// Clears all the data in the ComponentMaskChunkedVec
func (cv *ComponentMaskChunkedVec) Clear() {
	for e := cv.List.Front(); e != nil; e = e.Next() {
		cv.List.Remove(e)
	}
}

func (cv *ComponentMaskChunkedVec) String() string {
	var buff bytes.Buffer
	fmt.Fprintf(&buff, "{\n")
	for e := cv.List.Front(); e != nil; e = e.Next() {
		slice := e.Value.([]ComponentMask)
		if _, err := fmt.Fprintf(&buff, fmt.Sprintf("\t%s\n", slice)); err != nil {
			panic("Can't write to buffer")
		}
	}
	fmt.Fprintf(&buff, "\n}")

	return buff.String()
}
