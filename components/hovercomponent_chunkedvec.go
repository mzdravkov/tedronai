// Generated by: main
// TypeWriter: ChunkedVec
// Directive: +gen on HoverComponent

package components

import (
	"bytes"
	"container/list"
	"fmt"
)

// This is an implementation of https://github.com/mzdravkov/chunked-vector
// The MIT License (MIT)
// Copyright (c) 2016 Mihail Zdravkov (mihail0zdravkov@gmail.com)

type HoverComponentChunkedVec struct {
	List      *list.List
	ChunkSize uint
	Empty     HoverComponent
}

// Creates a new HoverComponentChunkedVec with chunkSize as provided
func NewHoverComponentChunkedVec(chunkSize uint) *HoverComponentChunkedVec {
	if chunkSize == 0 {
		chunkSize = 1024
	}

	return &HoverComponentChunkedVec{
		List:      list.New(),
		ChunkSize: chunkSize,
	}
}

// Adds the element to the ChunkedVec and returns the position it was added to
func (cv *HoverComponentChunkedVec) Add(element HoverComponent) (uint, uint) {
	listIndex := 0
	for e := cv.List.Front(); e != nil; e = e.Next() {
		for index, value := range e.Value.([]HoverComponent) {
			if value == cv.Empty {
				e.Value.([]HoverComponent)[index] = element
				return uint(listIndex), uint(index)
			}
		}

		listIndex++
	}

	slice := make([]HoverComponent, cv.ChunkSize)
	slice[0] = element
	cv.List.PushBack(slice)

	return uint(listIndex), uint(0)
}

// Overwrites the given position to hold the given value
func (cv *HoverComponentChunkedVec) PutAt(element HoverComponent, listIndex, sliceIndex uint) {
	var i uint = 0
	e := cv.List.Front()
	for ; i < listIndex; e = e.Next() {
		i++
	}

	e.Value.([]HoverComponent)[sliceIndex] = element
}

// Puts the cv.Empty value at the given position
func (cv *HoverComponentChunkedVec) DeleteAt(listIndex, sliceIndex uint) {
	cv.PutAt(cv.Empty, listIndex, sliceIndex)
}

// Returns the value that is on the given position
func (cv *HoverComponentChunkedVec) Get(listIndex, sliceIndex uint) HoverComponent {
	e := cv.List.Front()
	for i := uint(0); i < listIndex; e = e.Next() {
		i++
	}

	return e.Value.([]HoverComponent)[sliceIndex]
}

// Adds chunks (list nodes) to the HoverComponentChunkedVec
func (cv *HoverComponentChunkedVec) Grow(n int) {
	if n < 0 {
		panic("Can't grow HoverComponentChunkedVec with a negative amount")
	}

	for i := 0; i < n; i++ {
		slice := make([]HoverComponent, cv.ChunkSize)
		cv.List.PushBack(slice)
	}
}

// Remove list nodes that has arrays that are with the Empty element only
func (cv *HoverComponentChunkedVec) Shrink() {
	for e := cv.List.Front(); e != nil; e = e.Next() {
		allEmpty := true
		for _, value := range e.Value.([]HoverComponent) {
			if value != cv.Empty {
				allEmpty = false
				break
			}
		}

		if allEmpty {
			cv.List.Remove(e)
		}
	}
}

// Returns the number of non-empty valued elements
func (cv *HoverComponentChunkedVec) Len() int {
	number := 0

	for e := cv.List.Front(); e != nil; e = e.Next() {
		for _, value := range e.Value.([]HoverComponent) {
			if value != cv.Empty {
				number++
			}
		}
	}

	return number
}

// Returns the current capacity of the HoverComponentChunkedVec
// i.e. the number of elements it can currently hold without growing
func (cv *HoverComponentChunkedVec) Cap() int {
	return cv.List.Len() * int(cv.ChunkSize)
}

// Iter returns a channel of type HoverComponent that you can range over.
func (cv *HoverComponentChunkedVec) Iter() <-chan HoverComponent {
	ch := make(chan HoverComponent)

	go func() {
		for e := cv.List.Front(); e != nil; e = e.Next() {
			for _, value := range e.Value.([]HoverComponent) {
				ch <- value
			}
			close(ch)
		}
	}()

	return ch
}

// Checks if the HoverComponentChunkedVec contains the given element
func (cv *HoverComponentChunkedVec) Contains(element HoverComponent) bool {
	for e := cv.List.Front(); e != nil; e = e.Next() {
		for _, value := range e.Value.([]HoverComponent) {
			if value == element {
				return true
			}
		}
	}

	return false
}

// Checks if the HoverComponentChunkedVec contains all of the given element
func (cv *HoverComponentChunkedVec) ContainsAll(searchingFor ...HoverComponent) bool {
	for _, s := range searchingFor {
		if !cv.Contains(s) {
			return false
		}
	}

	return true
}

// Checks if this HoverComponentChunkedVec is equal to another one
// Two HoverComponentChunkedVecs are equal if they have the same number of lists
// with slices that have the same values
func (cv *HoverComponentChunkedVec) Equal(other *HoverComponentChunkedVec) bool {
	// no worries, the complexity of this is O(1)
	if cv.List.Len() != other.List.Len() {
		return false
	}

	e2 := other.List.Front()
	for e1 := cv.List.Front(); e1 != nil; e1 = e1.Next() {
		len1 := len(e1.Value.([]HoverComponent))
		len2 := len(e2.Value.([]HoverComponent))
		if len1 != len2 {
			return false
		}

		for i := 0; i < len1; i++ {
			if e1.Value.([]HoverComponent)[i] != e2.Value.([]HoverComponent)[i] {
				return false
			}
		}

		e2 = e2.Next()
	}

	return true
}

// Clone returns a clone of the HoverComponentChunkedVec.
// Does NOT clone the underlying elements.
func (cv *HoverComponentChunkedVec) Clone() *HoverComponentChunkedVec {
	clonedHoverComponentChunkedVec := NewHoverComponentChunkedVec(cv.ChunkSize)

	var listIndex uint = 0
	for e := cv.List.Front(); e != nil; e = e.Next() {
		for index, value := range e.Value.([]HoverComponent) {
			clonedHoverComponentChunkedVec.PutAt(value, listIndex, uint(index))
		}

		listIndex++
	}

	return clonedHoverComponentChunkedVec
}

// Clears all the data in the HoverComponentChunkedVec
func (cv *HoverComponentChunkedVec) Clear() {
	for e := cv.List.Front(); e != nil; e = e.Next() {
		cv.List.Remove(e)
	}
}

func (cv *HoverComponentChunkedVec) String() string {
	var buff bytes.Buffer
	fmt.Fprintf(&buff, "{\n")
	for e := cv.List.Front(); e != nil; e = e.Next() {
		slice := e.Value.([]HoverComponent)
		if _, err := fmt.Fprintf(&buff, fmt.Sprintf("\t%s\n", slice)); err != nil {
			panic("Can't write to buffer")
		}
	}
	fmt.Fprintf(&buff, "\n}")

	return buff.String()
}
