// Generated by: main
// TypeWriter: ChunkedVec
// Directive: +gen on SpaceComponent

package components

import (
	"bytes"
	"container/list"
	"fmt"
)

// This is an implementation of https://github.com/mzdravkov/chunked-vector
// The MIT License (MIT)
// Copyright (c) 2016 Mihail Zdravkov (mihail0zdravkov@gmail.com)

type SpaceComponentChunkedVec struct {
	list      *list.List
	ChunkSize uint
	Empty     SpaceComponent
}

// Creates a new SpaceComponentChunkedVec with chunkSize as provided
func NewSpaceComponentChunkedVec(chunkSize uint) *SpaceComponentChunkedVec {
	if chunkSize == 0 {
		chunkSize = 1024
	}

	return &SpaceComponentChunkedVec{
		list:      list.New(),
		ChunkSize: chunkSize,
	}
}

// Adds the element to the ChunkedVec and returns the position it was added to
func (cv *SpaceComponentChunkedVec) Add(element SpaceComponent) (uint, uint) {
	listIndex := 0
	for e := cv.list.Front(); e != nil; e = e.Next() {
		for index, value := range e.Value.([]SpaceComponent) {
			if value == cv.Empty {
				e.Value.([]SpaceComponent)[index] = element
				return uint(listIndex), uint(index)
			}
		}

		listIndex++
	}

	slice := make([]SpaceComponent, cv.ChunkSize)
	slice[0] = element
	cv.list.PushBack(slice)

	return uint(listIndex), uint(0)
}

// Overwrites the given position to hold the given value
func (cv *SpaceComponentChunkedVec) PutAt(element SpaceComponent, listIndex, sliceIndex uint) {
	var i uint = 0
	e := cv.list.Front()
	for ; i < listIndex; e = e.Next() {
		i++
	}

	e.Value.([]SpaceComponent)[sliceIndex] = element
}

// Puts the cv.Empty value at the given position
func (cv *SpaceComponentChunkedVec) DeleteAt(listIndex, sliceIndex uint) {
	cv.PutAt(cv.Empty, listIndex, sliceIndex)
}

// Returns the value that is on the given position
func (cv *SpaceComponentChunkedVec) Get(listIndex, sliceIndex uint) SpaceComponent {
	var i uint = 0
	e := cv.list.Front()
	for ; i < listIndex; e = e.Next() {
		i++
	}

	return e.Value.([]SpaceComponent)[sliceIndex]
}

// Remove list nodes that has arrays that are with the Empty element only
func (cv *SpaceComponentChunkedVec) Shrink() {
	for e := cv.list.Front(); e != nil; e = e.Next() {
		allEmpty := true
		for _, value := range e.Value.([]SpaceComponent) {
			if value != cv.Empty {
				allEmpty = false
				break
			}
		}

		if allEmpty {
			cv.list.Remove(e)
		}
	}
}

// Returns the number of non-empty valued elements
func (cv *SpaceComponentChunkedVec) Len() int {
	number := 0

	for e := cv.list.Front(); e != nil; e = e.Next() {
		for _, value := range e.Value.([]SpaceComponent) {
			if value != cv.Empty {
				number++
			}
		}
	}

	return number
}

// Returns the current capacity of the SpaceComponentChunkedVec
// i.e. the number of elements it can currently hold without growing
func (cv *SpaceComponentChunkedVec) Cap() int {
	return cv.list.Len() * int(cv.ChunkSize)
}

// Iter returns a channel of type SpaceComponent that you can range over.
func (cv *SpaceComponentChunkedVec) Iter() <-chan SpaceComponent {
	ch := make(chan SpaceComponent)

	go func() {
		for e := cv.list.Front(); e != nil; e = e.Next() {
			for _, value := range e.Value.([]SpaceComponent) {
				ch <- value
			}
			close(ch)
		}
	}()

	return ch
}

// Checks if the SpaceComponentChunkedVec contains the given element
func (cv *SpaceComponentChunkedVec) Contains(element SpaceComponent) bool {
	for e := cv.list.Front(); e != nil; e = e.Next() {
		for _, value := range e.Value.([]SpaceComponent) {
			if value == element {
				return true
			}
		}
	}

	return false
}

// Checks if the SpaceComponentChunkedVec contains all of the given element
func (cv *SpaceComponentChunkedVec) ContainsAll(searchingFor ...SpaceComponent) bool {
	for _, s := range searchingFor {
		if !cv.Contains(s) {
			return false
		}
	}

	return true
}

// Checks if this SpaceComponentChunkedVec is equal to another one
// Two SpaceComponentChunkedVecs are equal if they have the same number of lists
// with slices that have the same values
func (cv *SpaceComponentChunkedVec) Equal(other *SpaceComponentChunkedVec) bool {
	// no worries, the complexity of this is O(1)
	if cv.list.Len() != other.list.Len() {
		return false
	}

	e2 := other.list.Front()
	for e1 := cv.list.Front(); e1 != nil; e1 = e1.Next() {
		len1 := len(e1.Value.([]SpaceComponent))
		len2 := len(e2.Value.([]SpaceComponent))
		if len1 != len2 {
			return false
		}

		for i := 0; i < len1; i++ {
			if e1.Value.([]SpaceComponent)[i] != e2.Value.([]SpaceComponent)[i] {
				return false
			}
		}

		e2 = e2.Next()
	}

	return true
}

// Clone returns a clone of the SpaceComponentChunkedVec.
// Does NOT clone the underlying elements.
func (cv *SpaceComponentChunkedVec) Clone() *SpaceComponentChunkedVec {
	clonedSpaceComponentChunkedVec := NewSpaceComponentChunkedVec(cv.ChunkSize)

	var listIndex uint = 0
	for e := cv.list.Front(); e != nil; e = e.Next() {
		for index, value := range e.Value.([]SpaceComponent) {
			clonedSpaceComponentChunkedVec.PutAt(value, listIndex, uint(index))
		}

		listIndex++
	}

	return clonedSpaceComponentChunkedVec
}

// Clears all the data in the SpaceComponentChunkedVec
func (cv *SpaceComponentChunkedVec) Clear() {
	for e := cv.list.Front(); e != nil; e = e.Next() {
		cv.list.Remove(e)
	}
}

func (cv *SpaceComponentChunkedVec) String() string {
	var buff bytes.Buffer
	fmt.Fprintf(&buff, "{\n")
	for e := cv.list.Front(); e != nil; e = e.Next() {
		slice := e.Value.([]SpaceComponent)
		if _, err := fmt.Fprintf(&buff, fmt.Sprintf("\t%s\n", slice)); err != nil {
			panic("Can't write to buffer")
		}
	}
	fmt.Fprintf(&buff, "\n}")

	return buff.String()
}
